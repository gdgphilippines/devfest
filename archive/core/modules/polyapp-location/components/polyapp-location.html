<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../../../bower_components/polymer/polymer-element.html">

<script>
  (() => {
    'use strict'

    var workingURL

    var urlDoc, urlBase, anchor

    /**
     * @param {string} path
     * @param {string=} base
     * @return {!URL|!HTMLAnchorElement}
     */
    const resolveURL = (path, base) => {
      if (workingURL === undefined) {
        workingURL = false
        try {
          var u = new URL('b', 'http://a')
          u.pathname = 'c%20d'
          workingURL = (u.href === 'http://a/c%20d')
          workingURL = workingURL && (new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar')
        } catch (e) {}
      }
      if (workingURL) {
        return new URL(path, base)
      }
      if (!urlDoc) {
        urlDoc = document.implementation.createHTMLDocument('url')
        urlBase = urlDoc.createElement('base')
        urlDoc.head.appendChild(urlBase)
        anchor = /** @type {HTMLAnchorElement} */(urlDoc.createElement('a'))
      }
      urlBase.href = base
      anchor.href = path.replace(/ /g, '%20')
      return anchor
    }

    class PolyappLocation extends Polymer.Element {
      static get is () { return 'polyapp-location' }

      static get properties () {
        return {
          /**
           * The pathname component of the URL.
           */
          path: {
            type: String,
            notify: true,
            value: () => {
              return window.decodeURIComponent(window.location.pathname)
            }
          },

          /**
           * The query string portion of the URL.
           */
          query: {
            type: String,
            notify: true,
            value: () => {
              return window.location.search.slice(1);
            }
          },

          /**
           * The hash component of the URL.
           */
          hash: {
            type: String,
            notify: true,
            value: () => {
              return window.decodeURIComponent(window.location.hash.slice(1));
            }
          },

          /**
           * If the user was on a URL for less than `dwellTime` milliseconds, it
           * won't be added to the browser's history, but instead will be replaced
           * by the next entry.
           *
           * This is to prevent large numbers of entries from clogging up the user's
           * browser history. Disable by setting to a negative number.
           */
          dwellTime: {
            type: Number,
            value: 2000
          },

          /**
           * A regexp that defines the set of URLs that should be considered part
           * of this web app.
           *
           * Clicking on a link that matches this regex won't result in a full page
           * navigation, but will instead just update the URL state in place.
           *
           * This regexp is given everything after the origin in an absolute
           * URL. So to match just URLs that start with /search/ do:
           *     url-space-regex="^/search/"
           *
           * @type {string|RegExp}
           */
          urlSpaceRegex: {
            type: String,
            value: ''
          },

          /**
           * urlSpaceRegex, but coerced into a regexp.
           *
           * @type {RegExp}
           */
          _urlSpaceRegExp: {
            computed: '_makeRegExp(urlSpaceRegex)'
          },

          _lastChangedAt: {
            type: Number
          },

          _initialized: {
            type: Boolean,
            value: false
          }
        }
      }

      static get observers () {
        return [
          '_updateUrl(path, query, hash)'
        ]
      }

      constructor () {
        super()
        this.hostAttributes = {
          hidden: true
        }
        this._boundHashChanged = this._hashChanged.bind(this)
        this._boundUrlChanged = this._urlChanged.bind(this)
        this._boundGlobalOnClick = this._globalOnClick.bind(this)
      }

      connectedCallback () {
        super.connectedCallback()
        window.addEventListener('hashchange', this._boundHashChanged)
        window.addEventListener('location-changed', this._boundUrlChanged)
        window.addEventListener('popstate', this._boundUrlChanged)
        document.body.addEventListener('click', this._boundGlobalOnClick)
        this._lastChangedAt = window.performance.now() - (this.dwellTime - 200)
        this._initialized = true
        this._urlChanged()
      }

      disconnectedCallback () {
        window.removeEventListener('hashchange', this._boundHashChanged)
        window.removeEventListener('location-changed', this._boundUrlChanged)
        window.removeEventListener('popstate', this._boundUrlChanged)
        document.body.removeEventListener('click', this._boundGlobalOnClick)
        this._initialized = false
      }

      _hashChanged () {
        this.hash = window.decodeURIComponent(window.location.hash.substring(1));
      }

      _urlChanged () {
        // We want to extract all info out of the updated URL before we
        // try to write anything back into it.
        //
        // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
        // one when we set this.hash. Likewise for query.
        this._dontUpdateUrl = true
        this._hashChanged()
        this.path = window.decodeURIComponent(window.location.pathname)
        this.query = window.location.search.substring(1)
        this._dontUpdateUrl = false
        this._updateUrl()
      }

      _getUrl () {
        var partiallyEncodedPath = window.encodeURI(
            this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F')
        var partiallyEncodedQuery = ''
        if (this.query) {
          partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23')
        }
        var partiallyEncodedHash = ''
        if (this.hash) {
          partiallyEncodedHash = '#' + window.encodeURI(this.hash)
        }
        return (partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash)
      }

      _updateUrl () {
        if (this._dontUpdateUrl || !this._initialized) {
          return
        }

        if (this.path === window.decodeURIComponent(window.location.pathname) &&
            this.query === window.location.search.substring(1) &&
            this.hash === window.decodeURIComponent(
                window.location.hash.substring(1))) {
          // Nothing to do, the current URL is a representation of our properties.
          return
        }

        var newUrl = this._getUrl()
        // Need to use a full URL in case the containing page has a base URI.
        var fullNewUrl = resolveURL(newUrl, window.location.protocol + '//' + window.location.host).href
        var now = window.performance.now()
        var shouldReplace = this._lastChangedAt + this.dwellTime > now
        this._lastChangedAt = now

        if (shouldReplace) {
          window.history.replaceState({}, '', fullNewUrl)
        } else {
          window.history.pushState({}, '', fullNewUrl)
        }

        window.dispatchEvent(new CustomEvent('location-changed'))
        // this.fire('location-changed', {}, {node: window})
      }

      /**
       * A necessary evil so that links work as expected. Does its best to
       * bail out early if possible.
       *
       * @param {MouseEvent} event .
       */
      _globalOnClick (event) {
        // If another event handler has stopped this event then there's nothing
        // for us to do. This can happen e.g. when there are multiple
        // iron-location elements in a page.
        if (event.defaultPrevented) {
          return
        }

        var href = this._getSameOriginLinkHref(event)

        if (!href) {
          return
        }

        event.preventDefault()

        // If the navigation is to the current page we shouldn't add a history
        // entry or fire a change event.
        if (href === window.location.href) {
          return
        }

        window.history.pushState({}, '', href)
        window.dispatchEvent(new CustomEvent('location-changed'))
        // this.fire('location-changed', {}, {node: window});
      }

      /**
       * Returns the absolute URL of the link (if any) that this click event
       * is clicking on, if we can and should override the resulting full
       * page navigation. Returns null otherwise.
       *
       * @param {MouseEvent} event .
       * @return {string?} .
       */
      _getSameOriginLinkHref (event) {
        // We only care about left-clicks.
        if (event.button !== 0) {
          return null
        }

        var eventPath = event.composedPath() // Polymer.dom(event).path
        var anchor = null

        for (var i = 0; i < eventPath.length; i++) {
          var element = eventPath[i]

          if (element.tagName === 'A' && element.href) {
            anchor = element
            break
          }
        }

        // If there's no link there's nothing to do.
        if (!anchor) {
          return null
        }

        // We don't want modified clicks, where the intent is to open the page
        // in a new tab.
        if (event.metaKey || event.ctrlKey) {
          this._sendGa(anchor.href)
          return null
        }

        // Target blank is a new tab, don't intercept.
        if (anchor.target === '_blank') {
          this._sendGa(anchor.href)
          return null
        }

        // If the link is for an existing parent frame, don't intercept.
        if ((anchor.target === '_top' ||
            anchor.target === '_parent') &&
            window.top !== window) {
          this._sendGa(anchor.href)
          return null
        }

        var href = anchor.href

        // It only makes sense for us to intercept same-origin navigations.
        // pushState/replaceState don't work with cross-origin links.
        var url

        if (document.baseURI != null) {
          url = resolveURL(href, /** @type {string} */(document.baseURI));
        } else {
          url = resolveURL(href)
        }

        var origin

        // IE Polyfill
        if (window.location.origin) {
          origin = window.location.origin
        } else {
          origin = window.location.protocol + '//' + window.location.host
        }

        var urlOrigin

        if (url.origin) {
          urlOrigin = url.origin
        } else {
          urlOrigin = url.protocol + '//' + url.host
        }

        if (urlOrigin !== origin) {
          this._sendGa(anchor.href)
          return null
        }

        var normalizedHref = url.pathname + url.search + url.hash

        // pathname should start with '/', but may not if `new URL` is not supported
        if (normalizedHref[0] !== '/') {
          normalizedHref = '/' + normalizedHref
        }

        // If we've been configured not to handle this url... don't handle it!
        if (this._urlSpaceRegExp &&
            !this._urlSpaceRegExp.test(normalizedHref)) {
          this._sendGa(anchor.href)
          return null
        }

        // Need to use a full URL in case the containing page has a base URI.
        var fullNormalizedHref = resolveURL(
            normalizedHref, window.location.href).href
        return fullNormalizedHref
      }

      _makeRegExp (urlSpaceRegex) {
        return RegExp(urlSpaceRegex)
      }

      _sendGa (url) {
        if (window.ga) {
          ga('send', 'event', 'Link Out', 'click', url)
        }
      }
    }

    window.customElements.define(PolyappLocation.is, PolyappLocation)
  })()
</script>
